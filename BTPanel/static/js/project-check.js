import{c as e,r as a,k as l,g as t,p as r,q as c,v as o,e as i,A as s,x as m,F as u,a_ as p,H as d,I as n,y as h,B as _,z as v,aj as k,a9 as f,a7 as w,ai as b}from"./base-lib.js?v=1756369731";import{T as j,K as g,j as V,b as y,e as x}from"./utils-lib.js?v=1756369731";import{groupProjectConfig as D}from"./site.js?v=1756369731";import"./__commonjsHelpers__.js?v=1756369731";const E={class:"p-[2rem]"},q={class:"flex items-center mt-[1.6rem] ml-[3rem]"},U={class:"mt-[1.6rem] leading-8 text-[1.2rem] list-disc ml-[2rem]"},A=x(e({__name:"project-check",props:{compData:{default:{}}},setup(e,{expose:x}){const A=e,F=y(),H=a(),I=a(!1),N=l({check:"a;;",port:"",wait_time:180}),z={check:{required:!0,message:"请输入检测策略",trigger:"blur"},port:[{validator:(e,a,l)=>{a.split(",").filter(e=>""!==e).some(e=>!j(e))&&"port"==N.check?l(new Error("请输入正确的端口")):l()}}],wait_time:[{validator:(e,a,l)=>{a<=0&&"active"==N.check||""==a&&"active"==N.check?l(new Error("请输入正确的进程存活时长")):l()}}]},B=[{value:"all",label:"任意端口监听"},{value:"port",label:"指定端口监听"},{value:"active",label:"进程存活时长"}],C=t(()=>{switch(N.check){case"all":return"任意端口监听策略，执行启动后,项目进程直到出现任意一个端口监听后, 才认定为启动成功,最大默认等待3分钟";case"port":return"指定端口监听策略，执行启动后，项目进程直到监听【".concat(N.port,"】端口后，才认定为启动成功,最大默认等待3分钟");case"active":return"进程存活时长，解释:启动该项目后，在【".concat(N.wait_time,"】秒内自动退出则认定为启动成功");default:return""}});return r(()=>{var e,a,l,t,r;e=A.compData,N.check=(null==(a=e.check_info)?void 0:a.type)||"all","port"===N.check&&0==(null==(l=e.check_info)?void 0:l.port.length)&&(N.check="all"),N.port=(null==(t=e.check_info)?void 0:t.port.join(","))||"",N.wait_time=Number((null==(r=e.check_info)?void 0:r.wait_time)||180)}),x({onConfirm:async e=>{if("active"==N.check&&(N.wait_time<=0||""==N.wait_time))return F.error("请输入正确的进程存活时长");await H.value.validate(),g({loading:I,request:D({group_id:A.compData.group_id,project_id:A.compData.id,check_info:JSON.stringify({type:"all"==N.check?"port":N.check,port:"port"==N.check?N.port.split(","):[],wait_time:"active"==N.check?N.wait_time:180})}),success:a=>{a.status&&(A.compData.refreshEvent&&A.compData.refreshEvent(),e&&e())}})}}),(e,a)=>{const l=b,t=k,r=f,j=V,g=w;return c(),o("div",E,[i(g,{ref_key:"javaAddFormRef",ref:H,model:m(N),disabled:m(I),"label-width":"9rem",rules:z},{default:s(()=>[i(r,{label:"检测策略",prop:"check"},{default:s(()=>[i(t,{modelValue:m(N).check,"onUpdate:modelValue":a[0]||(a[0]=e=>m(N).check=e),class:"!w-[22rem]",placeholder:"请选择"},{default:s(()=>[(c(),o(u,null,p(B,e=>i(l,{key:e.value,label:e.label,value:e.value},null,8,["label","value"])),64))]),_:1},8,["modelValue"])]),_:1}),d(i(r,{label:"端口",prop:"port"},{default:s(()=>[i(j,{modelValue:m(N).port,"onUpdate:modelValue":a[1]||(a[1]=e=>m(N).port=e),placeholder:"多个用,分隔",width:"22rem"},null,8,["modelValue"])]),_:1},512),[[n,"port"==m(N).check]]),d(h("div",q,[a[3]||(a[3]=_(" 启动该项目后，在 ",-1)),i(j,{modelValue:m(N).wait_time,"onUpdate:modelValue":a[2]||(a[2]=e=>m(N).wait_time=e),type:"number",width:"8rem",class:"!mx-[1rem]"},null,8,["modelValue"]),a[4]||(a[4]=_(" 秒内自动退出则认定为启动成功 ",-1))],512),[[n,"active"==m(N).check]])]),_:1},8,["model","disabled"]),h("ul",U,[h("li",null,"当前效果："+v(m(C)),1),a[5]||(a[5]=h("li",null," 检查策略：主要是为了确认当前项目是否启动成功，保证顺序启动时，能在合适的情况下中断后续操作 ",-1)),a[6]||(a[6]=h("li",null,"任意端口监听策略（默认）：启动后，进程出现监听任意端口视为启动成功（最大等待3分钟）",-1)),a[7]||(a[7]=h("li",null," 指定端口监听策略：启动后，进程出现监听了您指定的所有端口后，视为启动成功（最大等待3分钟） ",-1)),a[8]||(a[8]=h("li",null,"进程存活时长：启动后，进程在指定时长内未退出，则视为启动成功",-1))])])}}}),[["__scopeId","data-v-e00f7f0c"]]);export{A as default};
